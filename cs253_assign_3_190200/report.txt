To run the programs:
chmod u+rx generate reduce
* If algo_reduce binary is absent run: g++ -o algo_reduce algo_reduce.cpp*

./generate path/to/program.cpp number_of_testcases (example ./generate test/P.cpp 1000) 
./reduce path/to/program.cpp path/to/input/file K (example ./reduce test/P.cpp T 20)

The outputs of generate.sh are written to file T.
The outputs of reduce.sh (reduce.cpp) are written to file S.
______________________________________________________________
1. generate

generate script takes the name of the program and number of test cases to produce as the input and randomly generates the testcases (with 2 inputs per test case) and stores them in the file T.

It uses the $RANDOM variable in bash which generates a random 15 bit unsigned integer. So I joined 3 such 15 bit random integers to create a 45 bit random integer, and then bit-shifted the extra 13 bits to create a 32 bit unisigned integer. From this, 2147483648 was subtracted to yield a 32 bit signed integer.

2. reduce

reduce script consists of 2 parts. 

a) First is extracting the branch information by running gcov on the inputs from the file generated by generate.sh. The input C program is compiled using gcc and then each input from file T is run on the compiled program. After each run, branch coverage information is extracted using gcov. gcov -b -c -t outputs the complete gcov file on the terminal with complete branch information, and the number of times each branch is executed.

This information for each branch for each test case is stored in an array called oneHot, along with information about the number of branches in the program and the number of inputs in the program.

Then, the binary algo_reduce is executed (compiled from algo_reduce.cpp program), with its inputs being $N $tc_len $K $len ${testCases[@]} ${oneHot[@]}, where N is the number of test cases, tc_len is number of inputs in each test case, K is maximum number of test cases to be selected, len is the number of branches in the program, testCases are the individual test cases which have been written in file T. 

b) algo_reduce.cpp is the implementation of the algorithm used to select K testcases out of the testbench of N testcases. It first converts the branch information extracted by reduce.sh into one-hot vectors. (For example if there are 30 branches in the program, then the final oneHot array will contain N rows, each containing 30 values, which will be either 0 if the branch was not taken in that test case, or 1 if the branch was taken in the testcase). This is prepared by subtracting the number of times a branch was executed till a test case from the number of times the same branch was executed till the previous test case.
Thus, in a one hot vector, the sum of all its values will give the number of branches taken in that test case.

After this array of one hot vectors is prepared, we use a greedy algorithm to try to select the K best test cases. 

We loop until K test cases are not selected, or till the branch coverage of the selected test cases does not become equal to the branch coverage of the entire test set, whichever is before.

In each iteration, we select the test case having the maximum branch coverage among the uncovered brancches (sum of the values of branches taken by this test case and not taken earlier [which is stored in the takenBranches vector] should be maximum). Ties are broken in order of encountering the test case (the test case which comes before is selected in case of a tie). After selecting this test case, we update the takenBranches vector, which is a vector maintaining all the branches previously taken, and add any new branches taken by the selected test case which weren't already taken. Now, this test case is written to file S, and the next iteration starts.

The time complexity of this approach is O(NKb) where N is the number of test cases, K is the number of test cases to select, and b is the number of branches in a program.

This problem was similar to the set cover problem in combinatorics (https://en.wikipedia.org/wiki/Set_cover_problem) which is a NP-hard problem for searching, which is the problem we had to solve. 

This greedy implementation is a reasonably performing algorithm for this problem under most ordinary circumstances, complexity wise, as stated in the Wikipedia article linked above.